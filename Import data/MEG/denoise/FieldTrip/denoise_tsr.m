function [data] = denoise_tsr(cfg, data)% DENOISE the data using the TSPCA algorithm%% Use as%  data = denoise_tsr(cfg, data)%% The data should be organised in a structure as obtained from the% PREPROCESSING function. The configuration should be according to%%  cfg.shifts     = array of shifts to apply to refs (default = [0])%  cfg.toobig1    = ignore data samples with absolute value > toobig1 (default = keep all)%  cfg.toobig2    = ignore data samples with value > toobig2 * weighted mean (default = keep all)%  cfg.toobig3    = ignore ref samples with absolute value > toobig1 (default = keep all)%  cfg.toobig4    = ignore ref samples with value > toobig2 * weighted mean (default = keep all)%  cfg.channel    = data channels to be denoised (default = 'all')%  cfg.refchannel = reference channels to use for the denoising%% This implements:%  de Cheveigne, A. and Simon, J. Z. (2008). "Sensor Noise Suppression"%  Journal of Neuroscience Methods 168: 195-202.% TODO % - rename the loop variables from "o, k, n, m" into something that is easier to read% - use the available detrending in FT instead of demean% - get it to work on variable trial length data% - move the outlier detection to another function (artifact_threahold probably does it already)% - check the literature reference% Copyright 2007/2008 Alain de Cheveigne, Laboratoire de Psychologie de la Perception,% CNRS and Universite Paris Descartes, and Departement d'Etudes Cognitives, Ecole% Normale Superieure, Paris. This software is provided as-is with no warranty.% This software is provided for SCIENTIFIC RESEARCH purposes only. If you use the% tools (or the algorithms, or the ideas) in your research, you MUST cite the% references below in all publications derived from this research. If you wish to use% these tools (or the algorithms, or the ideas) in a product, you MUST contact% Alain.de.Cheveigne AT ens.fr for permission and/or licensing details.%% $Log: denoise_tsr.m,v $% Revision 1.3  2008/03/14 12:04:19  roboos% added trial selection for consistency with other fieldtrip functions%% Revision 1.2  2008/03/14 11:58:02  roboos% changed todo list%% Revision 1.1  2008/03/14 10:21:12  roboos% initial implementation, based on wrap_tsr%% check that the low-level toolbox is available and on the pathhastoolbox('denoise', 1);% the data must be as obtained from preprocessingdata = checkdata(data, 'datatype', 'raw', 'hasoffset', 'no');% set the defaultsif ~isfield(cfg, 'skip'),        cfg.skip = [];          endif ~isfield(cfg, 'shifts'),      cfg.shifts = [];        endif ~isfield(cfg, 'toobig1'),     cfg.toobig1 = [];       endif ~isfield(cfg, 'toobig2'),     cfg.toobig2 = [];       endif ~isfield(cfg, 'toobig3'),     cfg.toobig3 = [];       endif ~isfield(cfg, 'toobig4'),     cfg.toobig4 = [];       endif ~isfield(cfg, 'channel'),     cfg.channel = 'all';    endif ~isfield(cfg, 'refchannel'),  cfg.refchannel = 'all'; endif ~isfield(cfg, 'trials'),      cfg.trials = 'all';     end% select trials of interestif ~strcmp(cfg.trials, 'all')  fprintf('selecting %d trials\n', length(cfg.trials));  data.trial  = data.trial(cfg.trials);  data.time   = data.time(cfg.trials);  % update the trial definition (trl)  if isfield(data, 'cfg') % try to locate the trl in the nested configuration    trl = findcfg(data.cfg, 'trl');  else    trl = [];  end  if isempty(trl)    % a trial definition is expected in each continuous data set    warning('could not locate the trial definition ''trl'' in the data structure');  else    cfg.trlold=trl;    cfg.trl=trl(cfg.trials,:);  endend% select channelscfg.channel     = channelselection(cfg.channel, data.label);chansel         = match_str(data.label, cfg.channel);cfg.refchannel  = channelselection(cfg.refchannel, data.label);refchansel      = match_str(data.label, cfg.refchannel);display(' transfer data to 3D matrix...');o = numel(data.trial);[n,m] = size(data.trial{1});x = zeros(m,numel(chansel),o);for k = 1:o  if [n,m] ~= size(data.trial{k}); error(['unexpected size for trial ',num2str(k),': ',num2str(size(data.trial{k}))]); end  xx = data.trial{k}';  x(:,:,k) = xx(:,chansel);enddisplay(' transfer ref to 3D matrix...');y = zeros(m,numel(refchansel),o);for k = 1:o  if [n,m] ~= size(data.trial{k}); error(['unexpected size for trial ',num2str(k),': ',num2str(size(data.trial{k}))]); end  xx = data.trial{k}';  y(:,:,k) = xx(:,refchansel);endif ~isempty(cfg.toobig1) || ~isempty(cfg.toobig2)  display(' find data outliers...');  wdata = find_outliers(x,cfg.toobig1,cfg.toobig2);  wdata = min(wdata,[],2);  disp([' done, ',num2str(100*(1 - sum(wdata(:)/numel(wdata)))), '% of data samples will be ignored by TSPCA']);else  wdata = [];endif ~isempty(cfg.toobig3) || ~isempty(cfg.toobig4)  display(' find ref outliers...');  wref = find_outliers(y,cfg.toobig3,cfg.toobig4);  wref = min(wref,[],2);  disp([' done, ',num2str(100*(1 - sum(wref(:)/numel(wref)))), '% of ref samples will be ignored by TSPCA']);else  wref = [];enddisp(' remove channel means...');x = demean(x,wdata);y = demean(y,wdata);disp(' call tsr()...');% hack: call tsr with 1 channel data just to get idx (avoids allocating extra variable)[dummy,idx] = tsr(x(:,1,:),y,cfg.shifts);clear dummyp0 = wpwr(x(idx,:,:));if isempty(wdata);  p1 = p0;else  p1 = wpwr(x(idx,:,:),wdata(idx,:,:));end% call tsr[x,idx] = tsr(x,y,cfg.shifts,wdata,wref);if ~isempty(wdata);  wdata = wdata(idx,:,:); % trimendp2 = wpwr(x);p3 = wpwr(x,wdata);disp([' done, remains ',num2str(100*p2/p0),'% of power (weighted: ',num2str(100*p3/p1), '%)']);% shorten the time arraysfor k = 1:o  t = data.time{k};  data.time{k} = t(idx);enddisp([' warning: trials shortened by ', num2str(idx(1)-1), ' at begining and ', num2str(m-idx(end)), ' at end']);% FIXME this should also be updated in the trial definition:w!disp(' transfer data back to fieldtrip struct...');for k = 1:o  xx = data.trial{k}';  xx = xx(idx,:,:);  xx(:,chansel) = x(:,:,k);  data.trial{k} = xx';enddisp('done')% add version information to the configurationtry  % get the full name of the function  cfg.version.name = mfilename('fullpath');catch  % required for compatibility with Matlab versions prior to release 13 (6.5)  [st, i] = dbstack;  cfg.version.name = st(i);endcfg.version.id = '$Id: denoise_tsr.m,v 1.3 2008/03/14 12:04:19 roboos Exp $';% remember the configuration details of the input datatry, cfg.previous = data.cfg; end% remember the exact configuration details in the outputdata.cfg = cfg;